<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>バーチャル月接近 – 3D風（WebGL2）</title>
  <style>
    :root{--panel:#0b1220;--edge:#1f2937;--text:#e5e7eb;--muted:#9ca3af;--accent:#38bdf8}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;display:grid;grid-template-rows:1fr auto;background:#000;color:var(--text);font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif}
    #stage{position:relative}
    canvas{display:block;width:100%;height:100%;background:#000}
    #ui{display:flex;gap:10px;flex-wrap:wrap;align-items:center;padding:10px;background:rgba(10,15,30,.75);border-top:1px solid var(--edge)}
    .ctrl{display:flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid var(--edge);border-radius:10px;background:var(--panel)}
    .ctrl label{font-size:12px;color:var(--muted)}
    input[type="range"]{width:140px}
    .btn{cursor:pointer;border:1px solid var(--edge);background:#0b1220;color:var(--text);padding:8px 12px;border-radius:10px}
    .btn:hover{border-color:#334155;background:#0d1627}
    .file{position:relative}
    .file input{position:absolute;inset:0;opacity:0;cursor:pointer}
    #hint{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:#94a3b8;text-align:center}
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="cv"></canvas>
    <div id="hint">画像を読み込むか「デモ月」を押してください<br>（クリックで寄り先を指定）</div>
  </div>
  <div id="ui">
    <div class="ctrl file"><button class="btn">画像を読み込む</button><input id="file" type="file" accept="image/*"></div>
    <button class="btn" id="demo">デモ月</button>
    <button class="btn" id="play">▶ 再生</button>
    <button class="btn" id="pause">⏸ 停止</button>
    <button class="btn" id="reset">↺ リセット</button>
    <button class="btn" id="rec">● 録画</button>
    <a class="btn" id="save" download="moon_zoom_3d.webm" style="display:none">⬇ 保存</a>
    <div class="ctrl"><label>時間</label><input id="dur" type="range" min="5" max="60" step="1" value="20"><span id="durv">20s</span></div>
    <div class="ctrl"><label>最終ズーム</label><input id="zoom" type="range" min="1.2" max="6" step="0.1" value="3"><span id="zoomv">3.0×</span></div>
    <div class="ctrl"><label>パンX</label><input id="panx" type="range" min="0" max="0.12" step="0.005" value="0.04"><span id="panxv">0.04</span></div>
    <div class="ctrl"><label>パンY</label><input id="pany" type="range" min="0" max="0.08" step="0.005" value="0.02"><span id="panyv">0.02</span></div>
    <div class="ctrl"><label>凹凸</label><input id="relief" type="range" min="0" max="4" step="0.05" value="1.2"><span id="reliefv">1.2</span></div>
    <div class="ctrl"><label>方位</label><input id="az" type="range" min="0" max="360" step="1" value="45"><span id="azv">45°</span></div>
    <div class="ctrl"><label>仰角</label><input id="el" type="range" min="5" max="85" step="1" value="25"><span id="elv">25°</span></div>
  </div>

<script>
const cv = document.getElementById('cv');
const hint = document.getElementById('hint');
let W=0,H=0, playing=false, startT=0, paused=0;
let gl=null, prog=null, vao=null, tex=null, img=null, anchor=null;
let recorder=null, chunks=[], recording=false;

const ui = {
  file: document.getElementById('file'), demo: document.getElementById('demo'),
  play: document.getElementById('play'), pause: document.getElementById('pause'), reset: document.getElementById('reset'),
  rec: document.getElementById('rec'), save: document.getElementById('save'),
  dur: sel('dur'), zoom: sel('zoom'), panx: sel('panx'), pany: sel('pany'), relief: sel('relief'), az: sel('az'), el: sel('el')
};
function sel(id){const el=document.getElementById(id); const v=document.getElementById(id+'v'); el.addEventListener('input',()=>{ if(v){v.textContent=(id==='dur'?el.value+'s': id==='az'||id==='el'?Math.round(+el.value)+'°' : (+el.value).toFixed(2)+(id==='zoom'?'×':''));}}); return el;}

function resize(){ const dpr=Math.min(2,devicePixelRatio||1); W=cv.clientWidth; H=cv.clientHeight; cv.width=Math.round(W*dpr); cv.height=Math.round(H*dpr); if(gl) gl.viewport(0,0,cv.width,cv.height); draw(0); }
window.addEventListener('resize', resize);

function initGL(){
  gl = cv.getContext('webgl2', {antialias:true, preserveDrawingBuffer:true});
  if(!gl){ alert('WebGL2未対応の環境です'); return; }
  const vs = `#version 300 es\nprecision highp float;layout(location=0) in vec2 p;out vec2 vUv;void main(){vUv=p*0.5+0.5;gl_Position=vec4(p,0.,1.);} `;
  const fs = `#version 300 es\nprecision highp float;in vec2 vUv;out vec4 o;uniform sampler2D uTex;uniform vec2 uTexSize;uniform vec4 uCrop;uniform vec2 uCanvas;uniform vec3 uLight;uniform float uRelief;float lum(vec3 c){return dot(c,vec3(.299,.587,.114));}void main(){vec2 tc=(uCrop.xy+vUv*uCrop.zw)/uTexSize; vec3 col=texture(uTex,tc).rgb; vec2 step=1.0/uTexSize; float hC=lum(col); float hL=lum(texture(uTex, tc+vec2(-step.x,0)).rgb); float hR=lum(texture(uTex, tc+vec2(step.x,0)).rgb); float hU=lum(texture(uTex, tc+vec2(0,-step.y)).rgb); float hD=lum(texture(uTex, tc+vec2(0, step.y)).rgb); vec3 n=normalize(vec3((hL-hR)*uRelief,(hU-hD)*uRelief,1.0)); float diff=max(dot(n, normalize(uLight)),0.0); float amb=.45; float shade=amb+0.75*diff; o=vec4(col*shade,1.0);} `;
  function sh(type,src){const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s;}
  function progmk(){const p=gl.createProgram(); const v=sh(gl.VERTEX_SHADER,vs), f=sh(gl.FRAGMENT_SHADER,fs); gl.attachShader(p,v); gl.attachShader(p,f); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)) throw gl.getProgramInfoLog(p); return p;}
  prog = progmk(); gl.useProgram(prog);
  const buf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  vao=gl.createVertexArray(); gl.bindVertexArray(vao); gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
  tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
}

function setImage(im){ img=im; hint.style.display='none'; anchor={x:img.width/2,y:img.height/2}; // upload texture
  const off=document.createElement('canvas'); off.width=img.width; off.height=img.height; const ct=off.getContext('2d'); ct.drawImage(img,0,0); const dt=ct.getImageData(0,0,img.width,img.height); gl.bindTexture(gl.TEXTURE_2D, tex); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,img.width,img.height,0,gl.RGBA,gl.UNSIGNED_BYTE,dt.data); draw(0); }

function loadFile(file){ const url=URL.createObjectURL(file); const im=new Image(); im.onload=()=>{URL.revokeObjectURL(url); setImage(im)}; im.src=url; }
function loadDemo(){ const s=2000; const off=document.createElement('canvas'); off.width=off.height=s; const c=off.getContext('2d'); c.fillStyle='#000'; c.fillRect(0,0,s,s); const g=c.createRadialGradient(s/2,s/2,s*.2,s/2,s/2,s*.5); g.addColorStop(0,'#e6ded6'); g.addColorStop(1,'#5a5e6a'); c.fillStyle=g; c.beginPath(); c.arc(s/2,s/2,s*.48,0,Math.PI*2); c.fill(); const im=new Image(); im.onload=()=>setImage(im); im.src=off.toDataURL('image/png'); }

function ease(t){return 0.5-0.5*Math.cos(Math.min(1,Math.max(0,t))*Math.PI)}

function draw(t){ if(!img){ const g=cv.getContext('2d'); g.clearRect(0,0,cv.width,cv.height); return; }
  const D=+ui.dur.value*1000; const r=Math.max(0,Math.min(1,t/D)); const z=1+(+ui.zoom.value-1)*ease(r);
  const panA=+ui.panx.value*img.width, panB=+ui.pany.value*img.height; const panX=panA*Math.sin(2*Math.PI*r); const panY=panB*Math.sin(4*Math.PI*r+Math.PI/3);
  const ax=(anchor?anchor.x:img.width/2)+panX; const ay=(anchor?anchor.y:img.height/2)+panY; const cw=img.width/z, ch=img.height/z;
  const x1=Math.max(0,Math.min(img.width-cw, ax-cw/2)); const y1=Math.max(0,Math.min(img.height-ch, ay-ch/2));
  gl.useProgram(prog); gl.bindVertexArray(vao); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, tex);
  const uTexSize=gl.getUniformLocation(prog,'uTexSize'); gl.uniform2f(uTexSize, img.width, img.height);
  const uCrop=gl.getUniformLocation(prog,'uCrop'); gl.uniform4f(uCrop, x1,y1,cw,ch);
  const uCanvas=gl.getUniformLocation(prog,'uCanvas'); gl.uniform2f(uCanvas, cv.width, cv.height);
  const az=+ui.az.value*Math.PI/180, el=+ui.el.value*Math.PI/180; const lx=Math.cos(el)*Math.cos(az), ly=Math.cos(el)*Math.sin(az), lz=Math.sin(el);
  const uLight=gl.getUniformLocation(prog,'uLight'); gl.uniform3f(uLight, lx,ly,lz);
  const uRelief=gl.getUniformLocation(prog,'uRelief'); gl.uniform1f(uRelief, +ui.relief.value);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);
}

function tick(now){ if(!playing) return; if(!startT) startT = now - paused; const t=now-startT; draw(t); if(t>=+ui.dur.value*1000){ playing=false; if(recording) stopRec(); } else requestAnimationFrame(tick); }
function play(){ if(!img) return; if(playing) return; playing=true; requestAnimationFrame(tick); }
function pause(){ if(!playing) return; playing=false; paused=performance.now()-startT; }
function reset(){ playing=false; startT=0; paused=0; draw(0); }

cv.addEventListener('click', (e)=>{ if(!img) return; const r=cv.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top; // map to current crop
  const D=+ui.dur.value*1000; const r1=ease(Math.min(1,(playing?(performance.now()-startT):paused)/D)); const z=1+(+ui.zoom.value-1)*r1; const cw=img.width/z, ch=img.height/z; const scale=H/ch; const newW=cw*scale; const xOff=(W-newW)/2; const nx=(x-xOff)/scale; const ny=y/scale; const ax = Math.min(img.width, Math.max(0, nx + (img.width-cw)/2)); const ay = Math.min(img.height, Math.max(0, ny + (img.height-ch)/2)); anchor={x:ax,y:ay}; draw(playing?(performance.now()-startT):0); });

function startRec(){ if(recording||!img) return; chunks=[]; const stream=cv.captureStream(30); const mime=MediaRecorder.isTypeSupported('video/webm;codecs=vp9')?'video/webm;codecs=vp9':'video/webm'; recorder=new MediaRecorder(stream,{mimeType:mime}); recorder.ondataavailable=e=>{ if(e.data.size) chunks.push(e.data); }; recorder.onstop=()=>{ const blob=new Blob(chunks,{type:'video/webm'}); const url=URL.createObjectURL(blob); ui.save.href=url; ui.save.style.display='inline-block'; }; recorder.start(); recording=true; play(); }
function stopRec(){ if(!recording) return; recorder.stop(); recording=false; }

// wires
ui.file.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(f) loadFile(f); });
ui.demo.addEventListener('click', loadDemo);
ui.play.addEventListener('click', play); ui.pause.addEventListener('click', pause); ui.reset.addEventListener('click', reset);
ui.rec.addEventListener('click', ()=> recording? stopRec(): startRec());

// boot
initGL(); resize(); draw(0);
</script>
</body>
</html>
